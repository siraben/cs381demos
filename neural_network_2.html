<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Neural Networks Part 2: Structure & Forward Propagation</title>

  <!-- Social Media Preview Tags -->
  <meta property="og:title" content="Neural Networks Part 2: Structure & Forward Propagation Demo">
  <meta property="og:description" content="Visualize a simple feedforward neural network structure and how input signals propagate through layers.">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Neural Networks Part 2: Structure & Forward Propagation Demo">
  <meta name="twitter:description" content="Visualize a simple feedforward neural network structure and how input signals propagate through layers.">

  <!-- Plotly for any visualizations -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <!-- MathJax for equation rendering -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async></script>

  <!-- Link shared CSS -->
  <link rel="stylesheet" href="styles.css">
  <style>
    /* Specific styles for this page */
    .network-visualization svg {
        display: block;
        margin: 0 auto;
        max-width: 500px; /* Limit width */
    }
    .neuron-circle {
        stroke: #333;
        stroke-width: 1px;
    }
    .input-node-circle {
        fill: #90ee90; /* Light green */
    }
    .hidden-node-circle {
        fill: #add8e6; /* Light blue */
    }
    .output-node-circle {
        fill: #ffcccb; /* Light red */
    }
    .neuron-text {
        font-family: sans-serif;
        font-size: 10px;
        text-anchor: middle;
        dominant-baseline: middle;
        fill: #000;
        pointer-events: none; /* Allow clicks through text */
    }
    .connection-line {
        stroke: #888;
        stroke-width: 1;
    }
    .weight-text {
        font-family: sans-serif;
        font-size: 8px;
        text-anchor: middle;
        fill: #555;
        pointer-events: none;
    }
    .layer-label {
        font-family: sans-serif;
        font-size: 12px;
        font-weight: bold;
        text-anchor: middle;
    }

    .layer-output {
        margin-bottom: 0.5rem;
        font-family: monospace;
        font-size: 0.9em;
        min-height: 60px; /* Space for output values */
    }

  </style>
</head>
<body>
<div class="container">
  <h1>Neural Networks Part 2: Structure & Forward Propagation</h1>
  <p>Connecting neurons into layers to form a simple feedforward network and seeing how signals flow.</p>

  <div class="controls">
    <!-- Input Sliders -->
    <div class="control-box">
        <label for="x1Slider">Input x1:</label><br/>
        <input type="range" id="x1Slider" min="-2" max="2" step="0.1" value="1" /><br/>
        <span id="x1Value">1.0</span>
    </div>
    <div class="control-box">
        <label for="x2Slider">Input x2:</label><br/>
        <input type="range" id="x2Slider" min="-2" max="2" step="0.1" value="-0.5" /><br/>
        <span id="x2Value">-0.5</span>
    </div>
  </div>

  <div class="network-visualization">
     <svg id="networkSvg" width="500" height="250"></svg>
     <!-- SVG generated by JS -->
  </div>

   <div id="outputDisplay" style="text-align: left; margin: 1rem auto; max-width: 600px; background-color: #eee; padding: 15px; border-radius: 5px; font-family: monospace; font-size: 0.95em; line-height: 1.6;">
      <!-- Calculation details will be shown here -->
      <h4>Forward Propagation Steps:</h4>
      <div id="hiddenLayerOutput">Hidden Layer Outputs: ...</div>
      <div id="outputLayerOutput">Output Layer Output: ...</div>
  </div>

   <div id="outputSpacePlot" class="plot-container"></div>

  <div id="explanation">
    <h3>From Neuron to Network</h3>
    <p>
      In Part 1, we saw how a single neuron computes its output. Neural networks gain their power by connecting these neurons together in layers.
      A simple <strong>feedforward neural network</strong> consists of:
      <ul>
          <li>An <strong>Input Layer</strong>: Receives the initial data (e.g., features \(x_1, x_2\)).</li>
          <li>One or more <strong>Hidden Layers</strong>: Neurons in these layers process the inputs. The output of one layer becomes the input to the next.</li>
          <li>An <strong>Output Layer</strong>: Produces the final result(s) of the network (e.g., a classification or regression value).</li>
      </ul>
      Connections only go "forward" from one layer to the next; there are no loops back.
    </p>
    <h3>Forward Propagation</h3>
    <p>
        Forward propagation is the process of calculating the network's output for a given input. It involves passing the input data through each layer sequentially.
        For a network with one hidden layer:
        <ol>
            <li>The input \(\mathbf{x} = [x_1, x_2, ..., x_n]\) is fed into the input layer.</li>
            <li>For each neuron \(j\) in the hidden layer, calculate its weighted sum \(z_j^{(1)}\) and activation \(a_j^{(1)}\):
            \[ z_j^{(1)} = \sum_{i} w_{ji}^{(1)} x_i + b_j^{(1)} \]
            \[ a_j^{(1)} = g(z_j^{(1)}) \]
            where \(w_{ji}^{(1)}\) is the weight from input \(i\) to hidden neuron \(j\), \(b_j^{(1)}\) is the bias of hidden neuron \(j\), and \(g\) is the activation function for the hidden layer.</li>
            <li>The activations of the hidden layer \(\mathbf{a}^{(1)} = [a_1^{(1)}, a_2^{(1)}, ...]\) become the inputs for the output layer.</li>
            <li>For each neuron \(k\) in the output layer, calculate its weighted sum \(z_k^{(2)}\) and activation \(a_k^{(2)}\):
            \[ z_k^{(2)} = \sum_{j} w_{kj}^{(2)} a_j^{(1)} + b_k^{(2)} \]
            \[ y_k = a_k^{(2)} = h(z_k^{(2)}) \]
            where \(w_{kj}^{(2)}\) is the weight from hidden neuron \(j\) to output neuron \(k\), \(b_k^{(2)}\) is the bias of output neuron \(k\), and \(h\) might be a different activation function suitable for the output (e.g., sigmoid for binary classification).</li>
            <li>The final output is \(\mathbf{y} = [y_1, y_2, ...]\).</li>
        </ol>
        This demo will visualize this process for a small network.
    </p>
  </div>

  <div class="back-link">
    <a href="index.html">&larr; Back to Homepage</a>
  </div>

  <div class="footer">
    <em>Part 2 of a Neural Networks series. Visualizing network structure and forward propagation.</em>
  </div>
</div>

<!-- Include shared JS utilities -->
<script src="plotUtils.js"></script>
<!-- Specific JS for this demo (if needed) -->
<!-- <script src="neural_network_2.js"></script> -->

<script>
// Basic setup or interactivity can go here
console.log("Neural Network Demo Part 2 Loaded");

// Get HTML elements
const x1Slider = document.getElementById('x1Slider');
const x1Value = document.getElementById('x1Value');
const x2Slider = document.getElementById('x2Slider');
const x2Value = document.getElementById('x2Value');
const networkSvg = document.getElementById('networkSvg');
const hiddenLayerOutputDiv = document.getElementById('hiddenLayerOutput');
const outputLayerOutputDiv = document.getElementById('outputLayerOutput');
const outputSpacePlotDiv = document.getElementById('outputSpacePlot'); // Added plot div

// --- Network Definition ---
const sigmoid = z => 1 / (1 + Math.exp(-z));

// Fixed weights and biases for a 2-3-1 network
const weights_h = [ // Hidden layer weights [neuron][input]
    [0.5, -0.6], // Neuron h1 weights (w11, w12)
    [-1.0, 0.8], // Neuron h2 weights (w21, w22)
    [0.7, 1.1]   // Neuron h3 weights (w31, w32)
];
const biases_h = [0.1, -0.5, 0.3]; // Hidden layer biases (b1, b2, b3)

const weights_o = [-0.9, 0.4, -0.7]; // Output layer weights [output][hidden]
const bias_o = 0.2; // Output layer bias

const svgNS = "http://www.w3.org/2000/svg";
let nodeElements = { inputs: [], hidden: [], output: [] };
let lineElements = { h_lines: [], o_lines: [] };
let weightElements = { h_weights: [], o_weights: [] };

// --- Visualization Creation (SVG) ---
function createNetworkSVG() {
    networkSvg.innerHTML = ''; // Clear previous diagram
    const width = networkSvg.clientWidth;
    const height = networkSvg.clientHeight;
    const layerX = [width * 0.15, width * 0.5, width * 0.85]; // X positions for layers
    const nodeRadius = 20;

    nodeElements = { inputs: [], hidden: [], output: [] };
    lineElements = { h_lines: weights_h.map(() => []), o_lines: [] }; // Correct initialization
    weightElements = { h_weights: weights_h.map(() => []), o_weights: [] };

    // Layer Labels
    ['Input', 'Hidden (Sigmoid)', 'Output (Sigmoid)'].forEach((label, i) => {
        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('x', layerX[i]);
        text.setAttribute('y', height * 0.1);
        text.setAttribute('class', 'layer-label');
        text.textContent = label;
        networkSvg.appendChild(text);
    });

    // Create Nodes (circles + text)
    const createNode = (cx, cy, id, label, cssClass, layerArray) => {
        const group = document.createElementNS(svgNS, 'g');
        const circle = document.createElementNS(svgNS, 'circle');
        circle.setAttribute('cx', cx);
        circle.setAttribute('cy', cy);
        circle.setAttribute('r', nodeRadius);
        circle.setAttribute('class', `neuron-circle ${cssClass}`)
        circle.setAttribute('id', `${id}-circle`);

        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('x', cx);
        text.setAttribute('y', cy);
        text.setAttribute('class', 'neuron-text');
        text.setAttribute('id', `${id}-text`);
        text.textContent = label;

        group.appendChild(circle);
        group.appendChild(text);
        networkSvg.appendChild(group);
        layerArray.push({ group, circle, text, cx, cy });
    };

    // Input Nodes
    const inputYStep = height / 3;
    for (let i = 0; i < 2; i++) {
        createNode(layerX[0], height * 0.3 + i * inputYStep, `input-${i}`, `x${i+1}`, 'input-node-circle', nodeElements.inputs);
    }

    // Hidden Nodes
    const hiddenYStep = height / 4;
    for (let i = 0; i < 3; i++) {
        createNode(layerX[1], height * 0.2 + i * hiddenYStep, `hidden-${i}`, `h${i+1}`, 'hidden-node-circle', nodeElements.hidden);
    }

    // Output Node
    createNode(layerX[2], height * 0.5, `output-0`, 'y', 'output-node-circle', nodeElements.output);

    // Create Lines and Weight Text placeholders (initially empty)
    const createLine = (x1, y1, x2, y2, weight, lineArray, weightArray) => {
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('class', 'connection-line');
        networkSvg.insertBefore(line, networkSvg.firstChild); // Draw lines behind nodes
        lineArray.push(line);

        const weightText = document.createElementNS(svgNS, 'text');
        weightText.setAttribute('x', (x1 + x2) / 2);
        weightText.setAttribute('y', (y1 + y2) / 2 - 3); // Offset slightly above line
        weightText.setAttribute('class', 'weight-text');
        weightText.textContent = weight.toFixed(1);
        networkSvg.appendChild(weightText);
        weightArray.push(weightText);
    };

    // Input -> Hidden Lines
    nodeElements.inputs.forEach((inputNode, i) => {
        nodeElements.hidden.forEach((hiddenNode, j) => {
            createLine(inputNode.cx, inputNode.cy, hiddenNode.cx, hiddenNode.cy, weights_h[j][i], lineElements.h_lines[j], weightElements.h_weights[j]);
        });
    });

    // Hidden -> Output Lines
    nodeElements.hidden.forEach((hiddenNode, j) => {
        nodeElements.output.forEach((outputNode, k) => { // Loop in case of multiple outputs later
            createLine(hiddenNode.cx, hiddenNode.cy, outputNode.cx, outputNode.cy, weights_o[j], lineElements.o_lines, weightElements.o_weights);
        });
    });
}

// --- Forward Propagation Logic ---
function forwardPass(x1, x2) {
    const z_h = [0, 0, 0];
    const a_h = [0, 0, 0];
    for (let j = 0; j < 3; j++) {
        z_h[j] = weights_h[j][0] * x1 + weights_h[j][1] * x2 + biases_h[j];
        a_h[j] = sigmoid(z_h[j]);
    }

    let z_o = 0;
    for (let j = 0; j < 3; j++) {
        z_o += weights_o[j] * a_h[j];
    }
    z_o += bias_o;
    const y_out = sigmoid(z_o);

    return { z_h, a_h, z_o, y_out };
}

// --- Update Network Diagram and Text Output ---
function updateNetworkVisuals(x1, x2) {
    // Update slider value displays
    x1Value.textContent = x1.toFixed(1);
    x2Value.textContent = x2.toFixed(1);

    // Perform forward pass
    const { z_h, a_h, z_o, y_out } = forwardPass(x1, x2);

    // Update node text in SVG
    nodeElements.inputs[0].text.textContent = `x1=${x1.toFixed(1)}`;
    nodeElements.inputs[1].text.textContent = `x2=${x2.toFixed(1)}`;
    nodeElements.hidden.forEach((node, j) => {
        node.text.textContent = `a${j+1}=${a_h[j].toFixed(2)}`;
    });
    nodeElements.output[0].text.textContent = `y=${y_out.toFixed(2)}`;

    // Update calculation details text
    let hiddenLayerText = '<strong>Hidden Layer:</strong><br/>';
    for (let j = 0; j < 3; j++) {
        hiddenLayerText += `&nbsp;&nbsp;z_h${j+1} = w${j+1}1*x1 + w${j+1}2*x2 + b${j+1} = (${weights_h[j][0].toFixed(1)})(${x1.toFixed(1)}) + (${weights_h[j][1].toFixed(1)})(${x2.toFixed(1)}) + (${biases_h[j].toFixed(1)}) = ${z_h[j].toFixed(2)}<br/>`;
        hiddenLayerText += `&nbsp;&nbsp;a_h${j+1} = sigmoid(z_h${j+1}) = ${a_h[j].toFixed(3)}<br/>`;
    }
    hiddenLayerOutputDiv.innerHTML = hiddenLayerText;

    let outputLayerText = '<strong>Output Layer:</strong><br/>';
    outputLayerText += `&nbsp;&nbsp;z_o = w1*a_h1 + w2*a_h2 + w3*a_h3 + b_o = (${weights_o[0].toFixed(1)})(${a_h[0].toFixed(2)}) + (${weights_o[1].toFixed(1)})(${a_h[1].toFixed(2)}) + (${weights_o[2].toFixed(1)})(${a_h[2].toFixed(2)}) + (${bias_o.toFixed(1)}) = ${z_o.toFixed(2)}<br/>`;
    outputLayerText += `&nbsp;&nbsp;y = sigmoid(z_o) = ${y_out.toFixed(3)}<br/>`;
    outputLayerOutputDiv.innerHTML = outputLayerText;
}

// --- Update 2D Output Space Plot ---
let outputSpaceData = null; // Cache grid data

function calculateOutputSpace() {
    const steps = 20; // Resolution of the plot
    const range = 2.0;
    const x1_vals = [];
    const x2_vals = [];
    const z_vals = []; // Network output y

    for (let i = 0; i <= steps; i++) {
        x1_vals.push(-range + (2 * range * i) / steps);
        x2_vals.push(-range + (2 * range * i) / steps);
    }

    for (let j = 0; j <= steps; j++) {
        const row = [];
        const current_x2 = x2_vals[j];
        for (let i = 0; i <= steps; i++) {
            const current_x1 = x1_vals[i];
            const { y_out } = forwardPass(current_x1, current_x2);
            row.push(y_out);
        }
        z_vals.push(row);
    }
    outputSpaceData = { x: x1_vals, y: x2_vals, z: z_vals };
}

function updateOutputSpacePlot(current_x1, current_x2) {
    if (!outputSpaceData) {
        calculateOutputSpace();
    }

    const contourTrace = {
        x: outputSpaceData.x,
        y: outputSpaceData.y,
        z: outputSpaceData.z,
        type: 'contour',
        colorscale: 'Viridis',
        contours: {
            coloring: 'heatmap'
        },
        colorbar: {
            title: 'Network Output (y)',
            titleside: 'right'
        }
    };

    const markerTrace = {
        x: [current_x1],
        y: [current_x2],
        mode: 'markers',
        name: 'Current Input',
        marker: {
            color: 'red',
            size: 12,
            symbol: 'x'
        }
    };

    const layout = {
        title: 'Network Output Space (y) vs Inputs (x1, x2)',
        xaxis: { title: 'Input x1', range: [-2.1, 2.1] },
        yaxis: { title: 'Input x2', range: [-2.1, 2.1] },
        margin: { l: 50, r: 50, b: 50, t: 50, pad: 4 },
        hovermode: 'closest'
    };

    Plotly.react(outputSpacePlotDiv, [contourTrace, markerTrace], layout);
}

// --- Initialization ---
function initializeDemo() {
    createNetworkSVG();
    const initial_x1 = parseFloat(x1Slider.value);
    const initial_x2 = parseFloat(x2Slider.value);
    updateNetworkVisuals(initial_x1, initial_x2);
    updateOutputSpacePlot(initial_x1, initial_x2);
}

// Add event listeners
[x1Slider, x2Slider].forEach(slider => {
    slider.addEventListener('input', () => {
        const x1 = parseFloat(x1Slider.value);
        const x2 = parseFloat(x2Slider.value);
        updateNetworkVisuals(x1, x2);
        updateOutputSpacePlot(x1, x2); // Update marker position
    });
});

// Create the diagram and run initial calculation on load
document.addEventListener('DOMContentLoaded', initializeDemo);


</script>

</body>
</html> 